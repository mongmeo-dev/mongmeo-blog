---
Layout: post
title: Kafka Consumer
subtitle: 카프카에서 메시지를 가져가는 친구를 알아보자
tags: [MQ, Kakfa]
---

# Kafka Consumer

Kafka의 컨슈머는 특정 토픽의 파티션을 구독하고 있다가 파티션에 메시지가 들어오면 해당 메시지를 가져와 메시지를 처리하는 요소이다.

카프카의 컨슈머의 특징들에 대해 알아보자.

## Consumer Group

카프카의 컨슈머는 '컨슈머 그룹' 이라는 것으로 묶을 수 있다. 컨슈머 그룹에 속한 컨슈머는 1개 이상의 파티션을 구독하여 메시지를 처리할 수 있다.

여기서 주의해야 할 점은 컨슈머는 1개 이상의 파티션을 구독할 수 있지만 한 파티션은 하나의 컨슈머만 구독이 가능하다는 점이다.

이러한 특성으로 인해 파티션의 수보다 그룹에 속한 컨슈머의 수가 더 많을 경우 컨슈머 그룹에 속한 컨슈머 중 초과된 수 만큼의 컨슈머는 파티션을 할당받지 못 하고 불필요하게 스레드와 리소스만 점유하게 된다.

한 컨슈머 그룹은 다른 컨슈머 그룹과 완벽히 분리되어 있어 메시지 처리 시 다른 컨슈머 그룹에 영향을 받지 않는다는 장점을 가진다.

만약 컨슈머 그룹에 속한 컨슈머 중 특정 컨슈머에 장애가 발생한 경우 '그룹 코디네이터'는 해당 상황을 감지하고 장애가 발생한 컨슈머가 구독하고 있던 파티션을 그룹 내에 장애가 발생하지 않은 다른 컨슈머에게 할당한다. 이 과정을 '리밸런싱'이라고 한다.

## Offset

특정 파티션에 메시지가 발행되면 오프셋이 증가하게 된다. 오프셋은 파티션 내에 있는 메시지의 위치를 나타내며 0부터 시작하는 시퀀스 번호이다.

컨슈머는 구독하고 있는 파티션의 몇 번째 메시지까지 소비했는지 기억하기 위해 컨슈머별 오프셋을 저장하게 되는데, 카프카 버전 0.9 전에는 해당 정보를 주키퍼에 저장하다가 0.9부터 브로커 내 특정 토픽(__consumer_offsets)에 저장하게 된다.

이렇게 오프셋 정보를 저장하고 있다가 컨슈머 그룹에 새로운 컨슈머가 들어오거나 장애로 인해 추방되게 되면 리밸런싱이 일어나면서 새로 할당된 파티션의 컨슈머 오프셋을 조회한다. 이후 해당 오프셋 번호 이후부터 메시지를 가져오게 된다.

## Commit

특정 파티션에 있는 메시지를 어디까지 소비했는지 나타내기 위해서는 오프셋을 기록해야하는데, 오프셋을 기록할 때는 '커밋'된 오프셋을 저장하게 된다.

만약 리밸런싱이 일어났을 때 처리된 메시지의 오프셋보다 커밋된 오프셋이 더 작으면 해당 메시지는 중복되어 처리되고, 처리된 메시지의 오프셋보다 커밋된 오프셋이 더 크면 해당 메시지는 누락되게 된다.

카프카에서는 커밋을 할 수 있는 여러 방법을 제공한다.

### Auto Commit

커밋을 직접 관리하는 방법도 있지만 이는 매우 번거로운 작업이다. 그래서 카프카에서는 자동 커밋을 지원한다. 자동 커밋을 사용하기 위해서는 컨슈머 옵션 중 `enable.auto.commit=true`로 설정하면 된다.

컨슈머는 poll()을 실행하며 메시지를 가져오는데, 매 5초마다 오프셋을 커밋한다. 5초는 기본값이며 `auto.commit.interval.ms`옵션을 통해 조정할 수 있다.

컨슈머가 poll()요청을 할 때마다 커밋할 시간이 되었는지 확인하고, 커밋할 시간이 되었다면 poll()을 통해 가장 마지막으로 가져온 메시지의 오프셋을 커밋하게 된다.

자동 커밋은 커밋을 직접 관리하지 않아도 되어 사용하기 편리하지만 만약 자동 커밋 주기(5초)가 되기 전에 리밸런싱이 일어나게 되면 마지막으로 처리한 메시지의 오프셋보다 커밋한 오프셋의 크기가 더 작은 상황이 발생할 수 있다. 즉, 메시지가 중복처리된다.

### 수동 커밋

자동 커밋에서 발생할 수 있는 또 다른 문제가 있다. 컨슈머가 메시지를 처리하던 도중 자동 커밋 주기가 되어 오프셋이 커밋되었는데 컨슈머의 장애 등으로 인해 메시지가 정상적으로 처리되지 않았다면 리밸런싱이 일어났을 때 커밋된 오프셋이 처리된 메시지의 오프셋보다 큰 상황이 발생하게 된다. 

이런 경우에는 메시지의 누락이 발생하게 되는데, 만약 메시지가 절대로 누락되지 않아야 한다면 메시지의 처리가 끝났을 때 수동으로 커밋해야한다.

다만 이 경우에도 메시지의 중복을 피할 수는 없다. 메시지가 처리되고 커밋이 일어나기 직전에 컨슈머에 장애가 발생하여 리밸런싱이 일어날 경우 커밋된 오프셋이 처리된 메시지의 오프셋보다 작으므로 해당 메시지는 중복 처리된다.

결론적으로 수동 커밋은 적어도 한 번 처리를 보장한다.

## 또 다른 컨슘 방식

위에서 살펴본 컨슈머 그룹 방식은 특정 컨슈머 그룹이 특정 토픽을 구독하고 카프카가 그룹 내의 컨슈머에게 파티션을 분배하는 방식이었다.

만약 메시지가 Key:Value 형태이거나 어떤 파티션에 들어갈지 정확히 알 수 있고, 해당 메시지만 구독하고자 한다면 구독을 토픽 단위가 아닌 파티션 단위로도 할 수 있다.

또, 위에서 살펴본 컨슘 방식은 특정 파티션의 첫 번째 메시지부터 컨슘하게 되는데, 컨슘을 시작하고자 하는 오프셋 역시 지정하여 컨슘할 수 있다.



이렇게 컨슈머에 대해 간략히 살펴보았다. 컨슈머에 대한 더 자세한 내용은 추후 기회가 되면 다뤄보겠다.