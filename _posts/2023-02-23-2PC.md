---
Layout: post
title: 2 Pashe Commit
subtitle: 분산 트랜잭션을 처리하는 방법
tags: [DB, MSA]
---

# 2 Phase Commit

2 Phase Commit(2단계 커밋, 2PC)은 여러 노드들 사이에서 원자적인 트랜잭션을 보장하기 위한 기법이다.

여러 노드가 한 트랜잭션으로 작동해야 할 때 몇 가지 문제점이 생기게 된다.

- 일부 노드는 커밋되고 일부 노드는 장애로 인해 롤백 되는 경우
- 일부 노드에서는 제약조건 위반을 감지하여 롤백되고 일부 노드는 커밋되는 경우
- 네트워크 장애로 일부 노드에서는 타임아웃이 발생했으나 일부 노드는 커밋되는 경우

이런 문제들로 인해 일반적인 방법으로는 한 트랜잭션에 여러 노드가 참여해야 하는 경우 트랜잭션의 원자성을 보장할 수 없다.

이를 해결하기 위해 나온 것이 2단계 커밋이다.

## 2PC의 동작 과정

2단계 커밋은 여러 노드가 참여하는 트랜잭션의 원자성을 보장하기 위해 '코디네이터'라는 요소가 관여한다.

1. 애플리케이션이 분산 트랜잭션을 시작하기 원하면 애플리케이션이 코디네이터에게 트랜잭션 ID를 요청한다. (트랜잭션 ID는 unique)
2. 이후 각 참여자는 싱글 노드 트랜잭션을 시작하게 되는데, 이 때 애플리케이션이 참여자에게 트랜잭션 ID를 전달한다. 이 단계에서는 모든 노드들이 거부권을 가진다.
3. 모든 참여자들이 데이터를 읽거나 쓰고 난 뒤 커밋할 준비(혹은 실패)가 되면 phase 1을 시작한다. 

### phase 1

Phase 1에서는 코디네이터가 트랜잭션에 참여하는 노드들에게 prepare 신호를 보내서 커밋할 수 있는지 질의한다. prepare 신호를 받은 트랜잭션에 참여한 노드(참여자)는 'yes' 또d는 'no'를 응답하게 된다. 

### phase 2

모든 참여자가 'yes'를 응답하거나 어느 한 노드라도 'no'를 응답하게 되면 코디네이터는 phase 2로 넘어가 해당 트랜잭션을 commit하거나 abort 하라는 신호를 보내게 되고, 해당 신호를 받은 참여자들은 신호에 따라 트랜잭션을 commit하거나 abort 하게 된다.

이 단계에서 참여자중 일부 노드가 장애 등의 이유로 신호를 받지 못 하면 코디네이터는 해당 노드가 회복되어 commit 또는 abort를 수행할 수 있을 때 까지 신호 전송을 재시도한다.

phase 2에서 결정된 사안은 번복되거나 취소될 수 없으며 장애 등의 이유로 다운된 참여자는 회복된 이후 해당 작업을 수행하게 된다.

2PC은 이런 과정을 통해 여러 노드가 참여하는 트랜잭션의 **원자성**을 보장한다.

## 그런데 왜 잘 안쓸까

2PC에도 몇 가지 단점이 있다.

1. phase 1이 종료되고 phase 2가 시작되기 전 코디네이터가 다운되면 모든 참여자는 blocking된 상태로 코디네이터가 회복될 때까지 대기해야한다
   - 코디네이터는 해당 트랜잭션이 commit 되어야 할지 abort 되어야 할지 로그에 저장하여 놓기 때문에 코디네이터가 장애에서 복구되면 기록해둔 로그를 읽어 다시 phase 2 진행을 시도한다.
2. 모든 참여자가 yes 혹은 일부 노드가 no를 응답하기 전까지 모든 참여자가 대기해야 하므로 트랜잭션에 소요되는 시간이 증가하게 된다.
3. 2번과 연결되어 트랜잭션 소요 시간이 증가함에 따라 다음에 수행되어야 할 트랜잭션이 현재 진행중인 트랜잭션에 영향을 받거나 끼치는 트랜잭션일 경우 현재 진행중인 트랜잭션이 모두 종료될 때 까지 대기해야 한다. 이는 싱글 노드 트랜잭션에서도 발생하지만 2PC는 구조적으로 싱글 노드 커밋보다 소요되는 시간이 더 기므로 대기 시간이 증가한다.
4. 가용성이 떨어진다. 만약 2PC에 참여하는 노드의 가용성이 각각 99.5%라면 2PC를 사용했을 때의 가용성은 99% 정도이다. (가용성 = 트랜잭션 참여자의 가용성을 곱한 값)
5. NoSQL은 2PC를 지원하지 않음

## 그럼 뭘 써야 하는가

최근 MSA 등이 유행하며 각 서비스 별 데이터베이스의 분리를 많이 하게 되는데, 이런 경우 멀티 노드 트랜잭션은 불가피해진다. 

MSA의 장점 중 하나가 애플리케이션이 '폴리글랏<sub id="polyglot">[1]</sub>'하다는 점인데, 2PC를 사용하게 되면 데이터베이스의 선택지가 RDBMS로 한정되므로 이런 장점이 희석된다.

그래서 2PC없이 데이터의 일관성을 유지하기 위해 SAGA패턴 등을 사용하게 된다.

SAGA는 이후에 알아보자.



---

<a href="#polyglot">[1] : 다양한 언어를 사용하여 개발하는 아키텍처. 이 글에서 말하는 폴리글랏은 폴리글랏 저장소(Polyglot persistence)이며 상황 / 서비스에 맞는 저장소를 택하는 것을 의미한다.</a>

